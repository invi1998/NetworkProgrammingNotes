字节对齐和系统有关，也和编译器有关，具体到底是几字节对齐和本问题关系不大。主要是因为无论如何对齐，都是字节对齐，而不是bit对齐。也就是说指针的起始存放地址只可能是8的倍数，比如0x00,0x08,0x10,转换成二进制后三位永远是0。不可能出现0x02到0x22作为一个四字节的指针。

指针的值是虚拟内存的地址编号。而通常可分配的虚拟内存地址编号是一系列散列的值。根据架构不同，其散列的跨度不同。32位的以32位为跨度，假设最小内存地址编号可以为0，写成十六进制就是0x00000000。(其实0地址无法获取，默认的0地址是空指针)下一个内存地址编号的分配以32位对齐分配，也就是说编号为32，写成十六进制就是0x00000020。再下一个内存地址编号是64，写成十六进制是0x00000040。也就是说内存编号是以32递增的数字序列32 64 96 128 160等。写成二进制形式，其后几位都是0。64位同理。

所有的内存分配器在所有架构下分配的内存都会做对齐操作。函数地址在linux，gcc，x86下至少会对齐到2字节
so，总的来说，指针的最后一位一定是0。
gcc内部也是用这个特性然后用最后一位来区分虚函数指针和普通函数指针的
# 前文总结

核心架构浓缩总结实现的功能：
（1）服务器按照包头包体格式正确的接收客户端发送过来的数据包；
（2）根据手动的包的不同来执行不同的业务处理逻辑；
（3）把业务处理产生的结果数据包返回客户端；

咱们用到的主要技术
（1）epoll高并发通讯技术
（2）线程池技术来处理业务逻辑
（3）线程之间的同步技术包括互斥量、信号量
其他技术：信号，日志打印，fork()子进程，守护进程

借鉴了哪些官方nginx的精华代码
（1）master进程，多个worker子进程——进程框架；
nginx：热更新，worker子进程挂了master能够重新启动worker；重载配置文件
【卷1讲解的主要是框架——包括通讯框架、包括业务逻辑处理框架，这才是我们本门课程的核心和精粹】
（2）借鉴了epoll的一些实现代码；官方nginx用的ET【边缘触发模式】，咱们本项目中用的是水平触发模式LT
（3）借鉴了接收数据包，以及发送数据包的核心代码；
官方nginx对我们项目的实现帮助不小，咱们借鉴的都是nginx中最核心，最值得借鉴的优秀代码；

哪些内容我们没有借鉴官方nginx呢？
（1）比如epoll技术中我们采用LT模式来书写网络数据的接收和发送；
（2）自己写一套线程池来处理业务逻辑，调用适当的业务逻辑处理函数，直至处理完毕把数据发送回客户端；
（3）连接池 中 连接的 延迟 回收，以及专门处理数据发送的发送线程；

# 心跳包概念

c/s程序：都有责任把心跳包机制在程序代码中实现好，以确保程序能良好的工作以及应付意外的情形发生；


## 什么叫心跳包以及如何使用

心跳包其实就是 一个普通的数据包；
一般每个几十秒，最长一般也就是1分钟【10秒-60秒之间】，有客户端主动发送给服务器；服务器收到之后，一般会给客户端返回一个心跳包；
三路握手，tcp连接建立之后，才存在发送心跳包的问题—— 如果c不给s发心跳包，服务器会怎样；
约定 30秒发送 一次； 服务器可能会在90秒或者100秒内，主动关闭该客户端的socket连接；
作为一个好的客户端程序，如果你发送了心跳包给服务器，但是在90或者100秒之内，你[客户端]没有收到服务器回应的心跳包，那么
你就应该主动关闭与服务器端的链接，并且如果业务需要重连，客户端程序在关闭这个连接后还要重新主动再次尝试连接服务器端；
客户端程序 也有必要提示使用者 与服务器的连接已经断开；

## 为什么引入心跳包

常规客户端关闭，服务器端能感知到；
有一种特殊情况，连接断开c/s都感知不到；

tcp本身keepalive机制；不重点研究，大家可以自己百度，因为检测时间不好控制，所以不适合我们；
c /s程序运行在不同的两个物理电脑上；tcp已经建立；
拔掉c /s程序的网线； 拔掉网线导致服务器感知不到客户端断开，这个事实，大家一定要知道；
那位了应对拔网线，导致不知道对方是否断开了tcp连接这种事，这就是我们引入心跳包机制的原因；
超时没有发送来心跳包，那么就会将对端的socket连接close掉，回收资源；这就是心跳包的作用；
其他作用：检测网络延迟等等；大家以后遇到再研究；
我们这里讲解心跳包，主要目的就是检测双方的链接是否断开；

# 心跳包代码实战

## 接收心跳包与返回结果

心跳包（ping包）
规定消息代码为0；一般心跳包也不需要包体，只有包头就够了；

## 处理不发送心跳包的客户端

30秒；超过30*3 +10 =100秒，仍旧没收到心跳包，那么服务器端就把tcp断开；
增加配置Sock_WaitTimeEnable，Sock_MaxWaitTime
修改ReadConf()函数读取配置信息；
ngx_c_socket_time.cxx专门存放一些跟时间有关的函数；

AddToTimerQueue() :把一个连接的信息加入到时间队列中来；该函数由 ngx_event_accept()函数在连接成功连入时调用；
定时器队列：官方nginx，红黑树做定时器，时间轮，老师用multimap来做定时器；

谁又来处理时间队列中的数据呢？ 咱们的思路是 创建一个新线程，专门处理事件队列这个事；介绍新线程ServerTimerQueueMonitorThread();
GetOverTimeTimer();RemoveFirstTimer();procPingTimeOutChecking();zdClosesocketProc()
改造inRecyConnectQueue()；ServerRecyConnectionThread();clearAllFromTimerQueue（）

## 测试代码的书写
# 多线程的提出

用 “线程” 来解决客户端发送过来的 数据包
一个进程 跑起来之后缺省 就自动启动了一个 “主线程”，也就是我们一个worker进程一启动就等于只有一个“主线程”在跑；
我们现在涉及到了业务逻辑层面，这个就要用多线程处理，所谓业务逻辑：充值，抽卡，战斗；
充值，需要本服务器和专门的充值服务器通讯，一般需要数秒到数十秒的通讯时间。此时，我们必须采用多线程【100个多线程】处理方式；
一个线程因为充值被卡住，还有其他线程可以提供给其他玩家及时的服务；

所以，我们服务器端处理用户需求【用户逻辑/业务】的时候一般都会启动几十甚至上百个线程来处理，以保证用户的需求能够得到及时处理；
epoll， iocp(windows)，启动线程数cpu*2+2;
主线程 往消息队列中用inMsgRecvQueue()扔完整包（用户需求），那么一堆线程要从这个消息对列中取走这个包，所在必须要用互斥；
多线程名词
a)POSIX：表示可移植操作系统接口（Portable Operating System Interface of UNIX)。
b)POSIX线程：是POSIX的线程标准【大概在1995年左右标准化的】；它定义了创建和操纵线程的一套API（Application Programming Interface：应用程序编程接口），
说白了 定义了一堆我们可以调用的函数，一般是以pthread_开头，比较成熟，比较好用；我们就用这个线程标准；

# POSIX

1. POSIX解决什么问题

> 一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程(即并不需要和内核提供的系统调用来编程)。一个API定义了一组应用程序使用的编程接口。它们可以实现成调用一个系统，也可以通过调用多个系统来实现，而完全不使用任何系统调用也不存在问题。实际上，**API可以在各种\*不同的操作系统\*上实现给应用程序提供完全相同的接口，**而它们本身在这些系统上的实现却可能迥异。如下图，当应用程序调用printf()函数时，printf函数会调用C库中的printf，继而调用C库中的write，C库最后调用内核的write()。

<img src="https:////upload-images.jianshu.io/upload_images/7749898-c7caacfd3c3e820f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/531/format/webp" alt="img"  />

应用程序、C库和内核之间的关系

从程序员的角度看，系统调用无关紧要，只需要跟API打交道。相反，内核只跟系统调用打交道，库函数及应用程序是怎么系统调用不是内核所关心的。

> **完成同一功能，不同内核提供的系统调用（一个函数）是不同的**，例如创建进程，linux下是fork函数，windows下是creatprocess函数。好，我现在在linux下写一个程序，用到fork函数，那么这个程序该怎么往windows上移植？我需要把源代码里的fork通通改成creatprocess，然后重新编译...

主流的操作系统有两种，一种是Windows系统，另一种是Linux系统。由于操作系统的不同，API又分为Windows API和Linux API。在Windows平台开发出来的软件在Linux上无法运行，在Linux上开发的软件在Windows上又无法运行，这就导致了软件移植困难，POSIX(Protabl Operation System 可移植操作系统规范)应运而生。**
**

**posix标准的出现就是为了解决这个问题。**linux和windows都要实现基本的posix标准，linux把fork函数封装成posix_fork（随便说的），windows把creatprocess函数也封装成posix_fork，都声明在unistd.h里。这样，程序员编写普通应用时候，只用包含unistd.h，调用posix_fork函数，程序就在源代码级别可移植了。

2. posix 是什么？

可移植操作系统接口Portable Operating System Interface of UNIX，POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称。

# 线程池实战代码

## 为什么引入线程池

们完全不推荐用单线程的方式解决逻辑业务问题，我们推荐多线程开发方式；
线程池：说白了 就是 我们提前创建好一堆线程，并搞一个类来统一管理和调度这一堆线程【这一堆线程我们就叫做线程池】,
当来了一个任务【来了一个消息】的时候，我从这一堆线程中找一个空闲的线程去做这个任务【去干活/去处理这个消息】，
活干完之后，我这个线程里边有一个循环语句，我可以循环回来等待新任务，再有新任务的时候再去执行新的任务；
就好像这个线程可以回收再利用 一样；
线程池存在意义和价值；
a)事先创建好一堆线程，避免动态创建线程来执行任务，提高了程序的稳定性；有效的规避程序运行之中创建线程有可能失败的风险；
b)提高程序运行效率：线程池中的线程，反复循环再利用；
大家有兴趣，可以百度 线程池； 但是说到根上，用线程池的目的无非就两条：提高稳定性，提升整个程序运行效率，容易管理【使编码更清晰简单】

【pthread多线程库】 gcc 末尾要增加 -lpthread；
$(CC) - o $@ $^ -lpthread
CThreadPool【线程池管理类】
讲解了 Create()，ThreadFunc(),StopAll();

# 线程池的使用

## 线程池的初始化

## 线程池工作的激发

激发的时机：当我收到了一个完整的用户来的消息的时候，我就要激发这个线程池来获取消息开始工作；
那我激发代码放在哪里呢？

## 线程池完善和测试

a)我只开一个线程【线程数量过少，线程池中只有一个线程】,我们需要报告；
b)来多个消息会堆积，但是不会丢消息，消息会逐条处理；
c)开两个线程,执行正常，每个线程，都得到了一个消息并且处理；表面看起来，正常；

程序执行流程【可能不太全，后续讲到哪里缺了再补充不着急】
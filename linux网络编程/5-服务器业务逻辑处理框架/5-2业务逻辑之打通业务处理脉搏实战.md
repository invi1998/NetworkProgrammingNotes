# 线程池代码调整及补充说明

上一章在线程池里使用了两个互斥量，一个是专门用来处理出入消息队列的互斥量，一个是线程池中还用了一个互斥量。想了一下觉得这两个互斥量的使用有点重复，所以将出入消息队列代码进行重写，转移到线程池CThreadPool中来

```c++
// ------------------------------------------------------------------
// 收到一个完整的消息后，入消息队列，并触发线程池中的线程来处理该消息
void CThreadPool::inMsgRecvQueueAndSignal(char *buf)
{
    // 互斥
    int err = pthread_mutex_lock(&m_pthreadMutex);
    if (err!=0)
    {
        ngx_log_stderr(err,"CThreadPool::inMsgRecvQueueAndSignal()pthread_mutex_lock()失败，返回的错误码为%d!",err);
    }

    m_MsgRecvQueue.push_back(buf);          // 入消息队列
    ++m_iRecvMsgQueueCount;                 // 收消息队列数字+1，个人认为使用功能变量更方便一点，比m_MsgRecvQueue.size()高效

    // 取消互斥
    err = pthread_mutex_unlock();
    if (err!=0)
    {
        ngx_log_stderr(err,"CThreadPool::inMsgRecvQueueAndSignal()pthread_mutex_unlock()失败，返回的错误码为%d!",err);
    }

    // 可以激发一个线程来干活了
    Call();
    return;
    
}
```

然后入消息队列的代码也做了调整。之前是先把消息调用inMsgRecvQueue()入消息队列，然后调用Call()来调用线程池中的线程执行消息处理。现在改为只需要调用g_threadpool.inMsgRecvQueueAndSignal(c->pnewMemPointer);线程池的成员函数即可实现入消息队列并触发线程处理消息

```c++
// 收到一个完整的包后的处理函数 【plast表示最后阶段】
void CSocket::ngx_wait_request_handler_proc_plast(lpngx_connection_t c)
{
    // 把这段内存放到消息队列中来
    // int irmqc = 0;    // 消息队列中当前消息数量
    // inMsgRecvQueue(c->pnewMemPointer, irmqc);
    // 注意这里，我们把这段new出来的内存放到消息队列中，那么后续这段内存就不归连接池管理了
    // 也就是说，这段内存的释放就不能再连接池中进行释放了，而应该放到具体的业务函数中进行处理
    // 所以下面才会把ifnewrecvMem内存释放标记设置为false，指向内存的指针也设置为空NULL
    // ---------这里可能考虑触发业务逻辑，怎么触发业务逻辑，后续实现

    // 激发线程池中的某个线程来处理业务逻辑
    // g_threadPool.Call(irmqc);
    g_threadpool.inMsgRecvQueueAndSignal(c->pnewMemPointer);    // 入消息队列并触发线程处理消息

    c->ifnewrecvMem     = false;            // 内存不再需要释放，因为你收完整了包，这个包被上面调用inMsgRecvQueue()移入消息队列，那么释放内存就属于业务逻辑去干， 不需要回收连接到连接池中做了
    c->pnewMemPointer   = NULL;
    c->curStat          = _PKG_HD_INIT;     // 收包状态机的状态恢复为原始态，为收下一个包做准备
    c->precvbuf         = c->dataHeadInfo;  // 设置好收包的位置
    c->irecvlen         = m_iLenPkgHeader;  // 设置好要接收的数据的大小
    return;
}
```

同时原来CSocket类中的inMsgRecvQueue和outMsgRecvQueue也都删除，连带其实现定义都删除。同时将线程入口函数里第二个while该为判断线程池对象的消息队列

```c++
while ((pThreadPoolObj->m_MsgRecvQueue.size() == 0) && m_shutdown == false)
{
    ...
}
        
```



# 线程池实现具体业务之准备代码

## 一个简单的crc32校验算法介绍

## 引入新的CSocket子类

## 设计模式题外话

## 消息的具体设计

# threadRecvProcFunc()函数讲解

# 整体测试工作的开展

## 不做背锅侠

## 客户端测试代码的调整

## 
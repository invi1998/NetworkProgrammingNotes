# 业务逻辑细节写法说明

_HandleRegister(),_HandleLogIn()里边到底执行什么，是属于业务逻辑代码；写法，大家自己决定
发送数据代码下节实现

# 连接池中连接回收的深度思考

## 灵活创建连接池

服务器 7*24不间断，服务器稳定性是第一位的；一个服务器，如果不稳定，那么谈别的都是虚的；
稳定性：连接池连接回收问题；
如果客户端【张三】断线，服务器端立即回收连接，这个连接很可能被紧随其后连入的新客户端【李四】所使用，那么这里就很可能产生麻烦；
a)张三 funca(); —执行10秒，服务器从线程池中找一个线程来执行张三的任务；
b)执行到第5秒的时候，张三断线；
c)张三断线这个事情会被服务器立即感知到，服务器随后调用ngx_close_connection把原来属于张三这个连接池中的连接给回收了；
d)第7秒的时候，李四连上来了，系统会把刚才张三用过的连接池中的连接分配给李四【现在这个连接归李四使用】；
e)10秒钟到了，这个线程很可能会继续操纵 连接【修改读数据】；很可能导致服务器整个崩溃；这种可能性是非常有的；

## 连接池中连接的回收

一个连接，如果我们程序判断这个连接不用了；那么 不 应该把这个连接立即放到空闲队列里，而是 应该放到一个地方；
等待一段时间【60】，60秒之后，我再真正的回收这个连接到 连接池/空闲队列 中去，这种连接才可以真正的分配给其他用户使用；
为什么要等待60秒，就是需要确保即便用户张三真断线了，那么我执行的该用户的业务逻辑也一定能在这个等待时间内全部完成；
这个连接不立即回收是非常重要的，有个时间缓冲非常重要；这个可以在极大程度上确保服务器的稳定；
服务器程序要常年累月的优化；
（2.1）灵活创建连接池
（2.2）连接池中连接的回收
a)立即回收【accept用户没有接入时可以立即回收】 b)延迟回收【用户接入进来开始干活了】；
(2.2.1)立即回收 ngx_free_connection()；
(2.2.2)延迟回收 inRecyConnectQueue()，ServerRecyConnectionThread()

# 程序退出时线程的安全终止

多线程开发技术在我们这个项目中是全面开花的

# epoll事件处理的改造

## 增加新的事件处理函数

引入ngx_epoll_oper_event()函数取代ngx_epoll_add_event()；

## 调整对事件处理函数的调用

ngx_epoll_init(),ngx_event_accept(),ngx_epoll_process_events();

# 连接延迟回收的具体应用

recvproc()调用了inRecyConnectQueue(延迟回收)取代了ngx_close_connection(立即回收)
Initialize_subproc()子进程中干；
Shutdown_subproc()子进程中干